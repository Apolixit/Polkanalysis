//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading.Tasks;
using Substrate.NetApi.Model.Meta;
using System.Threading;
using Substrate.NetApi;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Extrinsics;

namespace Polkanalysis.Kusama.NetApiExt.Generated.Storage.v9430
{
    public sealed class MessageQueueStorage
    {
        /// <summary>
        /// Substrate client for the storage calls.
        /// </summary>
        private SubstrateClientExt _client;
        public string blockHash { get; set; } = null;

        /// <summary>
        /// >> BookStateForParams
        ///  The index of the first and last (non-empty) pages.
        /// </summary>
        public static string BookStateForParams(Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin key)
        {
            return RequestGenerator.GetStorage("MessageQueue", "BookStateFor", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> BookStateForDefault
        /// Default value as hex string
        /// </summary>
        public static string BookStateForDefault()
        {
            return "0x0000000000000000000000000000000000000000000000000000000000";
        }

        /// <summary>
        /// >> BookStateFor
        ///  The index of the first and last (non-empty) pages.
        /// </summary>
        public async Task<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.pallet_message_queue.BookState> BookStateFor(Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin key, CancellationToken token)
        {
            string parameters = BookStateForParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.pallet_message_queue.BookState>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ServiceHeadParams
        ///  The origin at which we should begin servicing.
        /// </summary>
        public static string ServiceHeadParams()
        {
            return RequestGenerator.GetStorage("MessageQueue", "ServiceHead", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> ServiceHeadDefault
        /// Default value as hex string
        /// </summary>
        public static string ServiceHeadDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ServiceHead
        ///  The origin at which we should begin servicing.
        /// </summary>
        public async Task<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin> ServiceHead(CancellationToken token)
        {
            string parameters = ServiceHeadParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> PagesParams
        ///  The map of page indices to pages.
        /// </summary>
        public static string PagesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("MessageQueue", "Pages", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> PagesDefault
        /// Default value as hex string
        /// </summary>
        public static string PagesDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Pages
        ///  The map of page indices to pages.
        /// </summary>
        public async Task<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.pallet_message_queue.Page> Pages(Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.polkadot_runtime_parachains.inclusion.EnumAggregateMessageOrigin, Substrate.NetApi.Model.Types.Primitive.U32> key, CancellationToken token)
        {
            string parameters = PagesParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.pallet_message_queue.Page>(parameters, blockHash, token);
            return result;
        }

        public MessageQueueStorage(SubstrateClientExt client)
        {
            _client = client;
        }
    }

    public sealed class MessageQueueConstants
    {
        /// <summary>
        /// >> HeapSize
        ///  The size of the page; this implies the maximum message size which can be sent.
        /// 
        ///  A good value depends on the expected message sizes, their weights, the weight that is
        ///  available for processing them and the maximal needed message size. The maximal message
        ///  size is slightly lower than this as defined by [`MaxMessageLenOf`].
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 HeapSize()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00000100");
            return result;
        }

        /// <summary>
        /// >> MaxStale
        ///  The maximum number of stale pages (i.e. of overweight messages) allowed before culling
        ///  can happen. Once there are more stale pages than this, then historical pages may be
        ///  dropped, even if they contain unprocessed overweight messages.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxStale()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x10000000");
            return result;
        }

        /// <summary>
        /// >> ServiceWeight
        ///  The amount of weight (if any) which should be provided to the message queue for
        ///  servicing enqueued items.
        /// 
        ///  This may be legitimately `None` in the case that you will call
        ///  `ServiceQueues::service_queues` manually.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseOpt<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.sp_weights.weight_v2.Weight> ServiceWeight()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseOpt<Polkanalysis.Kusama.NetApiExt.Generated.Model.v9430.sp_weights.weight_v2.Weight>();
            result.Create("0x010700A0DB215D133333333333333333");
            return result;
        }
    }

    public enum MessageQueueErrors
    {
        /// <summary>
        /// >> NotReapable
        /// Page is not reapable because it has items remaining to be processed and is not old
        /// enough.
        /// </summary>
        NotReapable,
        /// <summary>
        /// >> NoPage
        /// Page to be reaped does not exist.
        /// </summary>
        NoPage,
        /// <summary>
        /// >> NoMessage
        /// The referenced message could not be found.
        /// </summary>
        NoMessage,
        /// <summary>
        /// >> AlreadyProcessed
        /// The message was already processed and cannot be processed again.
        /// </summary>
        AlreadyProcessed,
        /// <summary>
        /// >> Queued
        /// The message is queued for future execution.
        /// </summary>
        Queued,
        /// <summary>
        /// >> InsufficientWeight
        /// There is temporarily not enough weight to continue servicing messages.
        /// </summary>
        InsufficientWeight,
        /// <summary>
        /// >> TemporarilyUnprocessable
        /// This message is temporarily unprocessable.
        /// 
        /// Such errors are expected, but not guaranteed, to resolve themselves eventually through
        /// retrying.
        /// </summary>
        TemporarilyUnprocessable
    }
}