//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading.Tasks;
using Substrate.NetApi.Model.Meta;
using System.Threading;
using Substrate.NetApi;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Extrinsics;

namespace Polkanalysis.Polkadot.NetApiExt.Generated.Storage.v9281
{
    public sealed class StakingStorage
    {
        /// <summary>
        /// Substrate client for the storage calls.
        /// </summary>
        private SubstrateClientExt _client;
        public string blockHash { get; set; } = null;

        /// <summary>
        /// >> HistoryDepthParams
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        public static string HistoryDepthParams()
        {
            return RequestGenerator.GetStorage("Staking", "HistoryDepth", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> HistoryDepthDefault
        /// Default value as hex string
        /// </summary>
        public static string HistoryDepthDefault()
        {
            return "0x54000000";
        }

        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Information is kept for eras in `[current_era - history_depth; current_era]`.
        /// 
        ///  Must be more than the number of eras delayed by session otherwise. I.e. active era must
        ///  always be in history. I.e. `active_era > current_era - history_depth` must be
        ///  guaranteed.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> HistoryDepth(CancellationToken token)
        {
            string parameters = HistoryDepthParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ValidatorCountParams
        ///  The ideal number of staking participants.
        /// </summary>
        public static string ValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> ValidatorCountDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorCountDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of staking participants.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> ValidatorCount(CancellationToken token)
        {
            string parameters = ValidatorCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MinimumValidatorCountParams
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public static string MinimumValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumValidatorCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MinimumValidatorCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumValidatorCountDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MinimumValidatorCount(CancellationToken token)
        {
            string parameters = MinimumValidatorCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> InvulnerablesParams
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("Staking", "Invulnerables", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> InvulnerablesDefault
        /// Default value as hex string
        /// </summary>
        public static string InvulnerablesDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32>> Invulnerables(CancellationToken token)
        {
            string parameters = InvulnerablesParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32>>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> BondedParams
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public static string BondedParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Bonded", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> BondedDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> Bonded(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = BondedParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MinNominatorBondParams
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public static string MinNominatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinNominatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MinNominatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinNominatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }

        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinNominatorBond(CancellationToken token)
        {
            string parameters = MinNominatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MinValidatorBondParams
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public static string MinValidatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinValidatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MinValidatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinValidatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }

        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinValidatorBond(CancellationToken token)
        {
            string parameters = MinValidatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MinCommissionParams
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public static string MinCommissionParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinCommission", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MinCommissionDefault
        /// Default value as hex string
        /// </summary>
        public static string MinCommissionDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill> MinCommission(CancellationToken token)
        {
            string parameters = MinCommissionParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> LedgerParams
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public static string LedgerParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Ledger", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> LedgerDefault
        /// Default value as hex string
        /// </summary>
        public static string LedgerDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.StakingLedger> Ledger(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = LedgerParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.StakingLedger>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> PayeeParams
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public static string PayeeParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Payee", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> PayeeDefault
        /// Default value as hex string
        /// </summary>
        public static string PayeeDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumRewardDestination> Payee(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = PayeeParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumRewardDestination>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ValidatorsParams
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// </summary>
        public static string ValidatorsParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Validators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> ValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorsDefault()
        {
            return "0x0000";
        }

        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ValidatorPrefs> Validators(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = ValidatorsParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ValidatorPrefs>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> CounterForValidatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForValidators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> CounterForValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForValidatorsDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForValidators(CancellationToken token)
        {
            string parameters = CounterForValidatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MaxValidatorsCountParams
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxValidatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxValidatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MaxValidatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxValidatorsCountDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxValidatorsCount(CancellationToken token)
        {
            string parameters = MaxValidatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> NominatorsParams
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// </summary>
        public static string NominatorsParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Nominators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> NominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string NominatorsDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  [`Config::MaxNominations`] configuration is decreased. In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Nominations> Nominators(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = NominatorsParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Nominations>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> CounterForNominatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForNominatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForNominators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> CounterForNominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForNominatorsDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForNominators(CancellationToken token)
        {
            string parameters = CounterForNominatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> MaxNominatorsCountParams
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxNominatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxNominatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> MaxNominatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxNominatorsCountDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxNominatorsCount(CancellationToken token)
        {
            string parameters = MaxNominatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> CurrentEraParams
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public static string CurrentEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> CurrentEraDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentEraDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CurrentEra(CancellationToken token)
        {
            string parameters = CurrentEraParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ActiveEraParams
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public static string ActiveEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ActiveEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> ActiveEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ActiveEraDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ActiveEraInfo> ActiveEra(CancellationToken token)
        {
            string parameters = ActiveEraParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ActiveEraInfo>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasStartSessionIndexParams
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public static string ErasStartSessionIndexParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStartSessionIndex", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> ErasStartSessionIndexDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStartSessionIndexDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndex(Substrate.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = ErasStartSessionIndexParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasStakersParams
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakers", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> ErasStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersDefault()
        {
            return "0x000000";
        }

        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Exposure> ErasStakers(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = ErasStakersParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Exposure>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasStakersClippedParams
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public static string ErasStakersClippedParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersClipped", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> ErasStakersClippedDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersClippedDefault()
        {
            return "0x000000";
        }

        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Exposure> ErasStakersClipped(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = ErasStakersClippedParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.Exposure>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasValidatorPrefsParams
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public static string ErasValidatorPrefsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorPrefs", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> ErasValidatorPrefsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorPrefsDefault()
        {
            return "0x0000";
        }

        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ValidatorPrefs> ErasValidatorPrefs(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = ErasValidatorPrefsParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.ValidatorPrefs>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasValidatorRewardParams
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public static string ErasValidatorRewardParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorReward", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> ErasValidatorRewardDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorRewardDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasValidatorReward(Substrate.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = ErasValidatorRewardParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasRewardPointsParams
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public static string ErasRewardPointsParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasRewardPoints", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> ErasRewardPointsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasRewardPointsDefault()
        {
            return "0x0000000000";
        }

        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EraRewardPoints> ErasRewardPoints(Substrate.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = ErasRewardPointsParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EraRewardPoints>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ErasTotalStakeParams
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public static string ErasTotalStakeParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasTotalStake", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> ErasTotalStakeDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasTotalStakeDefault()
        {
            return "0x00000000000000000000000000000000";
        }

        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasTotalStake(Substrate.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = ErasTotalStakeParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ForceEraParams
        ///  Mode of era forcing.
        /// </summary>
        public static string ForceEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ForceEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> ForceEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ForceEraDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumForcing> ForceEra(CancellationToken token)
        {
            string parameters = ForceEraParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumForcing>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> SlashRewardFractionParams
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public static string SlashRewardFractionParams()
        {
            return RequestGenerator.GetStorage("Staking", "SlashRewardFraction", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> SlashRewardFractionDefault
        /// Default value as hex string
        /// </summary>
        public static string SlashRewardFractionDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill> SlashRewardFraction(CancellationToken token)
        {
            string parameters = SlashRewardFractionParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> CanceledSlashPayoutParams
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public static string CanceledSlashPayoutParams()
        {
            return RequestGenerator.GetStorage("Staking", "CanceledSlashPayout", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> CanceledSlashPayoutDefault
        /// Default value as hex string
        /// </summary>
        public static string CanceledSlashPayoutDefault()
        {
            return "0x00000000000000000000000000000000";
        }

        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> CanceledSlashPayout(CancellationToken token)
        {
            string parameters = CanceledSlashPayoutParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> UnappliedSlashesParams
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public static string UnappliedSlashesParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "UnappliedSlashes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> UnappliedSlashesDefault
        /// Default value as hex string
        /// </summary>
        public static string UnappliedSlashesDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.UnappliedSlash>> UnappliedSlashes(Substrate.NetApi.Model.Types.Primitive.U32 key, CancellationToken token)
        {
            string parameters = UnappliedSlashesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.UnappliedSlash>>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> BondedErasParams
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public static string BondedErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "BondedEras", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> BondedErasDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedErasDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> BondedEras(CancellationToken token)
        {
            string parameters = BondedErasParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ValidatorSlashInEraParams
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public static string ValidatorSlashInEraParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorSlashInEra", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> ValidatorSlashInEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorSlashInEraDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEra(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = ValidatorSlashInEraParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> NominatorSlashInEraParams
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public static string NominatorSlashInEraParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "NominatorSlashInEra", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat, Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, key.Value);
        }

        /// <summary>
        /// >> NominatorSlashInEraDefault
        /// Default value as hex string
        /// </summary>
        public static string NominatorSlashInEraDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> NominatorSlashInEra(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32> key, CancellationToken token)
        {
            string parameters = NominatorSlashInEraParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> SlashingSpansParams
        ///  Slashing spans for stash accounts.
        /// </summary>
        public static string SlashingSpansParams(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "SlashingSpans", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> SlashingSpansDefault
        /// Default value as hex string
        /// </summary>
        public static string SlashingSpansDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.slashing.SlashingSpans> SlashingSpans(Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32 key, CancellationToken token)
        {
            string parameters = SlashingSpansParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.slashing.SlashingSpans>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> SpanSlashParams
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public static string SpanSlashParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "SpanSlash", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] { Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat }, new Substrate.NetApi.Model.Types.IType[] { key });
        }

        /// <summary>
        /// >> SpanSlashDefault
        /// Default value as hex string
        /// </summary>
        public static string SpanSlashDefault()
        {
            return "0x0000000000000000000000000000000000000000000000000000000000000000";
        }

        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.slashing.SpanRecord> SpanSlash(Substrate.NetApi.Model.Types.Base.BaseTuple<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, CancellationToken token)
        {
            string parameters = SpanSlashParams(key);
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.slashing.SpanRecord>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> CurrentPlannedSessionParams
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public static string CurrentPlannedSessionParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentPlannedSession", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> CurrentPlannedSessionDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentPlannedSessionDefault()
        {
            return "0x00000000";
        }

        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CurrentPlannedSession(CancellationToken token)
        {
            string parameters = CurrentPlannedSessionParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> OffendingValidatorsParams
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public static string OffendingValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "OffendingValidators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> OffendingValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string OffendingValidatorsDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> OffendingValidators
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.Bool>>> OffendingValidators(CancellationToken token)
        {
            string parameters = OffendingValidatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.Bool>>>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> StorageVersionParams
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public static string StorageVersionParams()
        {
            return RequestGenerator.GetStorage("Staking", "StorageVersion", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> StorageVersionDefault
        /// Default value as hex string
        /// </summary>
        public static string StorageVersionDefault()
        {
            return "0x09";
        }

        /// <summary>
        /// >> StorageVersion
        ///  True if network has been upgraded to this version.
        ///  Storage version of the pallet.
        /// 
        ///  This is set to v7.0.0 for new networks.
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumReleases> StorageVersion(CancellationToken token)
        {
            string parameters = StorageVersionParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.pallet_staking.EnumReleases>(parameters, blockHash, token);
            return result;
        }

        /// <summary>
        /// >> ChillThresholdParams
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public static string ChillThresholdParams()
        {
            return RequestGenerator.GetStorage("Staking", "ChillThreshold", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }

        /// <summary>
        /// >> ChillThresholdDefault
        /// Default value as hex string
        /// </summary>
        public static string ChillThresholdDefault()
        {
            return "0x00";
        }

        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public async Task<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Percent> ChillThreshold(CancellationToken token)
        {
            string parameters = ChillThresholdParams();
            var result = await _client.GetStorageAsync<Polkanalysis.Polkadot.NetApiExt.Generated.Model.v9281.sp_arithmetic.per_things.Percent>(parameters, blockHash, token);
            return result;
        }

        public StakingStorage(SubstrateClientExt client)
        {
            _client = client;
        }
    }

    public sealed class StakingConstants
    {
        /// <summary>
        /// >> MaxNominations
        ///  Maximum number of nominations per nominator.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxNominations()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x10000000");
            return result;
        }

        /// <summary>
        /// >> SessionsPerEra
        ///  Number of sessions per era.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SessionsPerEra()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x06000000");
            return result;
        }

        /// <summary>
        /// >> BondingDuration
        ///  Number of eras that staked funds must remain bonded for.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 BondingDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x1C000000");
            return result;
        }

        /// <summary>
        /// >> SlashDeferDuration
        ///  Number of eras that slashes are deferred by, after computation.
        /// 
        ///  This should be less than the bonding duration. Set to 0 if slashes
        ///  should be applied immediately, without opportunity for intervention.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SlashDeferDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x1B000000");
            return result;
        }

        /// <summary>
        /// >> MaxNominatorRewardedPerValidator
        ///  The maximum number of nominators rewarded for each validator.
        /// 
        ///  For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can
        ///  claim their reward. This used to limit the i/o cost for the nominator payout.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxNominatorRewardedPerValidator()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00010000");
            return result;
        }

        /// <summary>
        /// >> MaxUnlockingChunks
        ///  The maximum number of `unlocking` chunks a [`StakingLedger`] can have. Effectively
        ///  determines how many unique eras a staker may be unbonding in.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxUnlockingChunks()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
    }

    public enum StakingErrors
    {
        /// <summary>
        /// >> NotController
        /// Not a controller account.
        /// </summary>
        NotController,
        /// <summary>
        /// >> NotStash
        /// Not a stash account.
        /// </summary>
        NotStash,
        /// <summary>
        /// >> AlreadyBonded
        /// Stash is already bonded.
        /// </summary>
        AlreadyBonded,
        /// <summary>
        /// >> AlreadyPaired
        /// Controller is already paired.
        /// </summary>
        AlreadyPaired,
        /// <summary>
        /// >> EmptyTargets
        /// Targets cannot be empty.
        /// </summary>
        EmptyTargets,
        /// <summary>
        /// >> DuplicateIndex
        /// Duplicate index.
        /// </summary>
        DuplicateIndex,
        /// <summary>
        /// >> InvalidSlashIndex
        /// Slash record index out of bounds.
        /// </summary>
        InvalidSlashIndex,
        /// <summary>
        /// >> InsufficientBond
        /// Cannot have a validator or nominator role, with value less than the minimum defined by
        /// governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
        /// intention, `chill` first to remove one's role as validator/nominator.
        /// </summary>
        InsufficientBond,
        /// <summary>
        /// >> NoMoreChunks
        /// Can not schedule more unlock chunks.
        /// </summary>
        NoMoreChunks,
        /// <summary>
        /// >> NoUnlockChunk
        /// Can not rebond without unlocking chunks.
        /// </summary>
        NoUnlockChunk,
        /// <summary>
        /// >> FundedTarget
        /// Attempting to target a stash that still has funds.
        /// </summary>
        FundedTarget,
        /// <summary>
        /// >> InvalidEraToReward
        /// Invalid era to reward.
        /// </summary>
        InvalidEraToReward,
        /// <summary>
        /// >> InvalidNumberOfNominations
        /// Invalid number of nominations.
        /// </summary>
        InvalidNumberOfNominations,
        /// <summary>
        /// >> NotSortedAndUnique
        /// Items are not sorted and unique.
        /// </summary>
        NotSortedAndUnique,
        /// <summary>
        /// >> AlreadyClaimed
        /// Rewards for this era have already been claimed for this validator.
        /// </summary>
        AlreadyClaimed,
        /// <summary>
        /// >> IncorrectHistoryDepth
        /// Incorrect previous history depth input provided.
        /// </summary>
        IncorrectHistoryDepth,
        /// <summary>
        /// >> IncorrectSlashingSpans
        /// Incorrect number of slashing spans provided.
        /// </summary>
        IncorrectSlashingSpans,
        /// <summary>
        /// >> BadState
        /// Internal state has become somehow corrupted and the operation cannot continue.
        /// </summary>
        BadState,
        /// <summary>
        /// >> TooManyTargets
        /// Too many nomination targets supplied.
        /// </summary>
        TooManyTargets,
        /// <summary>
        /// >> BadTarget
        /// A nomination target was supplied that was blocked or otherwise not a validator.
        /// </summary>
        BadTarget,
        /// <summary>
        /// >> CannotChillOther
        /// The user has enough bond and thus cannot be chilled forcefully by an external person.
        /// </summary>
        CannotChillOther,
        /// <summary>
        /// >> TooManyNominators
        /// There are too many nominators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyNominators,
        /// <summary>
        /// >> TooManyValidators
        /// There are too many validators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyValidators,
        /// <summary>
        /// >> CommissionTooLow
        /// Commission is too low. Must be at least `MinCommission`.
        /// </summary>
        CommissionTooLow
    }
}